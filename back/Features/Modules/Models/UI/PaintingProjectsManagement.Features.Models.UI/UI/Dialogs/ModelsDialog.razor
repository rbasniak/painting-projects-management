@using MudBlazor
@using PaintingProjectsManagement.UI.Modules.Models
@using PaintingProjectsManagement.UI.Modules.Shared

@namespace PaintingProjectsManagement.UI.Modules.Models.UI.Dialogs

<MudDialog Class="model-dialog">
    <DialogContent>
        <MudStack Spacing="3" Class="model-dialog-content">
            <MudGrid>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="Model.Name"
                                  Label="Name"
                                  Variant="Variant.Outlined"
                                  Required="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudAutocomplete @bind-Value="Model.Franchise"
                                     Label="Franchise"
                                     SearchFunc="SearchFranchises"
                                     ToStringFunc="(string s) => s"
                                     AllowCustomValues="true"
                                     CoerceValue="true"
                                     Immediate="true"
                                     OpenOnFocus="false"
                                     Variant="Variant.Outlined" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudSelect T="Guid"
                               @bind-Value="SelectedCategoryId"
                               Label="Category"
                               Variant="Variant.Outlined"
                               ToStringFunc="CategoryToString"
                               Required="true">
                        @foreach (var category in categories)
                        {
                            <MudSelectItem Value="@category.Id">@CategoryToString(category.Id)</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudSelect T="ModelType"
                               @bind-Value="SelectedType"
                               Label="Type"
                               Variant="Variant.Outlined"
                               Required="true">
                        @foreach (var type in Enum.GetValues<ModelType>())
                        {
                            <MudSelectItem Value="@type">@type</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudAutocomplete @bind-Value="Model.Artist"
                                     @bind-Text="_artistInput"
                                     Label="Artist"
                                     SearchFunc="SearchArtists"
                                     ToStringFunc="(string s) => s"
                                     AllowCustomValues="true"
                                     CoerceValue="true"
                                     Immediate="true"
                                     OpenOnFocus="false"
                                     Required="true"
                                     Variant="Variant.Outlined" />
                </MudItem>
                <MudItem xs="12" md="6" Class="d-flex align-center">
                    <MudCheckBox T="bool" @bind-Checked="Model.MustHave" Label="Must Have" Color="Color.Primary" />
                </MudItem>
            </MudGrid>

            @if (categories.Count == 0)
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">
                    Create at least one category before saving a model.
                </MudAlert>
            }

            <MudDivider />

            <MudGrid>
                <MudItem xs="12" md="6">
                    <MudPaper Outlined="true" Class="pa-4 collection-panel">
                        <MudStack Spacing="2">
                            <MudText Typo="Typo.subtitle1">Characters</MudText>
                            <MudAutocomplete T="string"
                                             Label="Characters"
                                             @bind-Text="_characterInput"
                                             SearchFunc="SearchCharacters"
                                             ToStringFunc="(string? s) => s ?? string.Empty"
                                             MultiSelection="true"
                                             SelectedValues="selectedCharacters"
                                             SelectedValuesChanged="OnCharactersChanged"
                                             AllowCustomValues="true"
                                             CoerceText="false"
                                             CoerceValue="true"
                                             Immediate="true"
                                             OpenOnFocus="false"
                                             Variant="Variant.Outlined" />
                            <MudText Typo="Typo.caption" Class="helper-muted">Type to search and press Enter to add.</MudText>
                            @if (selectedCharacters.Count == 0)
                            {
                                <MudText Typo="Typo.caption" Class="helper-muted">No characters selected.</MudText>
                            }
                            else
                            {
                                <MudChipSet T="string" Class="collection-chip-set">
                                    @foreach (var character in selectedCharacters.OrderBy(x => x))
                                    {
                                        <MudChip Value="@character"
                                                 Text="@character"
                                                 Variant="Variant.Outlined"
                                                 Color="Color.Primary"
                                                 Closeable="true"
                                                 OnClose="@((MudChip<string> _) => RemoveCharacter(character))" />
                                    }
                                </MudChipSet>
                            }
                        </MudStack>
                    </MudPaper>
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudPaper Outlined="true" Class="pa-4 collection-panel">
                        <MudStack Spacing="2">
                            <MudText Typo="Typo.subtitle1">Tags</MudText>
                            <MudAutocomplete T="string"
                                             Label="Tags"
                                             @bind-Text="_tagInput"
                                             SearchFunc="SearchTags"
                                             ToStringFunc="(string? s) => s ?? string.Empty"
                                             MultiSelection="true"
                                             SelectedValues="selectedTags"
                                             SelectedValuesChanged="OnTagsChanged"
                                             AllowCustomValues="true"
                                             CoerceText="false"
                                             CoerceValue="true"
                                             Immediate="true"
                                             OpenOnFocus="false"
                                             Variant="Variant.Outlined" />
                            <MudText Typo="Typo.caption" Class="helper-muted">Type to search and press Enter to add.</MudText>
                            @if (selectedTags.Count == 0)
                            {
                                <MudText Typo="Typo.caption" Class="helper-muted">No tags selected.</MudText>
                            }
                            else
                            {
                                <MudChipSet T="string" Class="collection-chip-set">
                                    @foreach (var tag in selectedTags.OrderBy(x => x))
                                    {
                                        <MudChip Value="@tag"
                                                 Text="@tag"
                                                 Variant="Variant.Outlined"
                                                 Color="Color.Secondary"
                                                 Closeable="true"
                                                 OnClose="@((MudChip<string> _) => RemoveTag(tag))" />
                                    }
                                </MudChipSet>
                            }
                        </MudStack>
                    </MudPaper>
                </MudItem>
            </MudGrid>
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Submit" Color="Color.Primary" Variant="Variant.Filled" Disabled="@(!CanSubmit)">Save</MudButton>
        <MudButton OnClick="Cancel">Cancel</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter] public ModelDetails Model { get; set; } = new();
    [Parameter] public List<ModelDetails> AllModels { get; set; } = new();
    [Inject] public IModelCategoriesService ModelCategoriesService { get; set; } = default!;

    [CascadingParameter] public MudBlazor.IMudDialogInstance? MudDialog { get; set; }

    private readonly StringComparer valueComparer = StringComparer.OrdinalIgnoreCase;
    private List<ModelCategoryDetails> categories = new();
    private Dictionary<Guid, string> knownCategoryNames = new();
    private HashSet<string> selectedCharacters = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> selectedTags = new(StringComparer.OrdinalIgnoreCase);
    private Guid selectedCategoryId;
    private ModelType selectedType = ModelType.Unknown;
    private string _tagInput = string.Empty;
    private string _characterInput = string.Empty;
    private string _artistInput = string.Empty;

    private bool CanSubmit =>
        !string.IsNullOrWhiteSpace(Model.Name) &&
        selectedCategoryId != Guid.Empty &&
        !string.IsNullOrWhiteSpace(GetArtistValue());

    private Guid SelectedCategoryId
    {
        get => selectedCategoryId;
        set
        {
            selectedCategoryId = value;
            var category = categories.FirstOrDefault(x => x.Id == value);
            if (category is not null)
            {
                Model.Category = new EntityReference(category.Id, CategoryToString(category.Id));
            }
        }
    }

    private ModelType SelectedType
    {
        get => selectedType;
        set
        {
            selectedType = value;
            Model.Type = new EnumReference((int)value, value.ToString());
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadCategories();
        InitializeState();
    }

    private async Task LoadCategories()
    {
        BuildKnownCategoryNames();

        categories = (await ModelCategoriesService.GetAllAsync(CancellationToken.None)).ToList();

        foreach (var category in categories)
        {
            if (HasInvalidCategoryName(category.Name) &&
                knownCategoryNames.TryGetValue(category.Id, out var knownName))
            {
                category.Name = knownName;
            }
        }

        foreach (var knownCategory in knownCategoryNames)
        {
            if (categories.All(x => x.Id != knownCategory.Key))
            {
                categories.Add(new ModelCategoryDetails
                {
                    Id = knownCategory.Key,
                    Name = knownCategory.Value
                });
            }
        }

        categories = categories
            .OrderBy(x => x.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private void BuildKnownCategoryNames()
    {
        knownCategoryNames = AllModels
            .Where(x => x.Category.Id != Guid.Empty && !HasInvalidCategoryName(x.Category.Name))
            .GroupBy(x => x.Category.Id)
            .ToDictionary(
                x => x.Key,
                x => x.Select(y => y.Category.Name)
                    .First(name => !HasInvalidCategoryName(name)));

        if (Model.Category.Id != Guid.Empty && !HasInvalidCategoryName(Model.Category.Name))
        {
            knownCategoryNames[Model.Category.Id] = Model.Category.Name;
        }
    }

    private void InitializeState()
    {
        Model.Characters ??= [];
        Model.Tags ??= [];
        Model.Franchise ??= string.Empty;
        Model.Artist ??= string.Empty;
        _artistInput = Model.Artist;

        selectedCharacters = new HashSet<string>(NormalizeValues(Model.Characters), valueComparer);
        selectedTags = new HashSet<string>(NormalizeValues(Model.Tags), valueComparer);

        Model.Characters = selectedCharacters.ToArray();
        Model.Tags = selectedTags.ToArray();

        var existingCategory = categories.FirstOrDefault(x => x.Id == Model.Category.Id);
        if (existingCategory is null && categories.Count > 0)
        {
            existingCategory = categories[0];
        }

        if (existingCategory is not null)
        {
            if (HasInvalidCategoryName(existingCategory.Name) &&
                knownCategoryNames.TryGetValue(existingCategory.Id, out var knownName))
            {
                existingCategory.Name = knownName;
            }

            selectedCategoryId = existingCategory.Id;
            Model.Category = new EntityReference(existingCategory.Id, CategoryToString(existingCategory.Id));
        }
        else
        {
            selectedCategoryId = Guid.Empty;
            Model.Category = new EntityReference(Guid.Empty, string.Empty);
        }

        var typeId = Model.Type.Id;
        selectedType = Enum.IsDefined(typeof(ModelType), typeId)
            ? (ModelType)typeId
            : ModelType.Unknown;

        Model.Type = new EnumReference((int)selectedType, selectedType.ToString());
    }

    private Task<IEnumerable<string>> SearchFranchises(string value, CancellationToken cancellationToken)
    {
        var source = AllModels
            .Where(x => !string.IsNullOrWhiteSpace(x.Franchise))
            .Select(x => x.Franchise);

        return Task.FromResult(FilterValues(source, value));
    }

    private Task<IEnumerable<string>> SearchCharacters(string value, CancellationToken cancellationToken)
    {
        var source = AllModels
            .SelectMany(x => x.Characters ?? [])
            .Where(x => !string.IsNullOrWhiteSpace(x));

        return Task.FromResult(FilterValues(source, value));
    }

    private Task<IEnumerable<string>> SearchArtists(string value, CancellationToken cancellationToken)
    {
        var source = AllModels
            .Where(x => !string.IsNullOrWhiteSpace(x.Artist))
            .Select(x => x.Artist!);

        return Task.FromResult(FilterValues(source, value));
    }

    private Task<IEnumerable<string>> SearchTags(string value, CancellationToken cancellationToken)
    {
        var source = AllModels
            .SelectMany(x => x.Tags ?? [])
            .Where(x => !string.IsNullOrWhiteSpace(x));

        return Task.FromResult(FilterValues(source, value));
    }

    private IEnumerable<string> FilterValues(IEnumerable<string> source, string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return [];
        }

        var trimmedValue = value.Trim();

        var results = source
            .Select(x => x.Trim())
            .Where(x => x.Contains(trimmedValue, StringComparison.OrdinalIgnoreCase))
            .Distinct(valueComparer)
            .OrderBy(x => x)
            .ToList();

        if (!results.Contains(trimmedValue, valueComparer))
        {
            results.Insert(0, trimmedValue);
        }

        return results;
    }

    private IEnumerable<string> NormalizeValues(IEnumerable<string> values)
    {
        return values
            .Select(x => x?.Trim())
            .Where(x => !string.IsNullOrWhiteSpace(x))
            .Cast<string>()
            .Distinct(valueComparer);
    }

    private void OnCharactersChanged(HashSet<string> newSelectedCharacters)
    {
        selectedCharacters = new HashSet<string>(NormalizeValues(newSelectedCharacters), valueComparer);
        Model.Characters = selectedCharacters.ToArray();
        _characterInput = string.Empty;
    }

    private void OnTagsChanged(HashSet<string> newSelectedTags)
    {
        selectedTags = new HashSet<string>(NormalizeValues(newSelectedTags), valueComparer);
        Model.Tags = selectedTags.ToArray();
        _tagInput = string.Empty;
    }

    private void RemoveTag(string tag)
    {
        if (selectedTags.Remove(tag))
        {
            Model.Tags = selectedTags.ToArray();
        }
    }

    private void RemoveCharacter(string character)
    {
        if (selectedCharacters.Remove(character))
        {
            Model.Characters = selectedCharacters.ToArray();
        }
    }

    private void Submit()
    {
        Model.Name = Model.Name.Trim();
        Model.Franchise = Model.Franchise.Trim();
        Model.Artist = GetArtistValue().Trim();
        Model.Characters = selectedCharacters.ToArray();
        Model.Tags = selectedTags.ToArray();
        MudDialog?.Close(DialogResult.Ok(Model));
    }
    
    private void Cancel()
    {
        MudDialog?.Cancel();
    }

    private static bool HasInvalidCategoryName(string? value)
    {
        return string.IsNullOrWhiteSpace(value) || Guid.TryParse(value, out _);
    }

    private string CategoryToString(Guid id)
    {
        if (id == Guid.Empty)
        {
            return string.Empty;
        }

        if (knownCategoryNames.TryGetValue(id, out var knownCategoryName) &&
            !HasInvalidCategoryName(knownCategoryName))
        {
            return knownCategoryName;
        }

        var categoryName = categories
            .FirstOrDefault(x => x.Id == id)?
            .Name;

        if (!HasInvalidCategoryName(categoryName))
        {
            return categoryName!;
        }

        return id.ToString();
    }

    private string GetArtistValue()
    {
        return !string.IsNullOrWhiteSpace(_artistInput)
            ? _artistInput
            : (Model.Artist ?? string.Empty);
    }
}

<style>
    .model-dialog .mud-dialog {
        width: min(860px, 96vw);
    }

    .model-dialog-content {
        padding-top: 0.25rem;
    }

    .collection-panel {
        height: 100%;
    }

    .collection-chip-set {
        min-height: 2.75rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .helper-muted {
        color: var(--mud-palette-text-secondary);
    }
</style>
